import { Unit } from '../types/content';

export const osUnits: Unit[] = [
  {
    id: 'unit1',
    title: 'Memory Management',
    hours: 20,
    topics: [
      {
        id: 'intro-memory',
        title: 'Introduction to Memory Management',
        content: `Memory Management is a crucial function of operating systems that handles the allocation, deallocation, and organization of memory resources. It ensures efficient use of memory while preventing conflicts between processes.`,
        keyPoints: [
          'Memory is a limited resource that must be managed efficiently',
          'OS must keep track of which parts of memory are in use',
          'Must allocate memory to processes when needed',
          'Must deallocate memory when processes finish',
          'Protects processes from interfering with each other'
        ],
        examples: [
          {
            title: 'Real-World Analogy',
            description: 'Think of memory like a library with bookshelves. The librarian (OS) must organize books (data), assign shelf space (memory allocation), and ensure students (processes) don\'t take each other\'s books (memory protection).',
          }
        ]
      },
      {
        id: 'memory-hierarchy',
        title: 'Memory Hierarchy',
        content: `Computer memory is organized in a hierarchy based on speed, cost, and capacity. Understanding this hierarchy is essential for efficient memory management.`,
        keyPoints: [
          'Registers: Fastest, smallest, most expensive (inside CPU)',
          'Cache Memory: Very fast, small, expensive (L1, L2, L3)',
          'Main Memory (RAM): Fast, moderate size, moderate cost',
          'Secondary Storage: Slow, large, cheap (HDD, SSD)'
        ],
        examples: [
          {
            title: 'Memory Hierarchy Example',
            description: 'Speed and Size Trade-off',
            visual: `
┌─────────────────────────────────────┐
│     REGISTERS (fastest)             │
│     Size: Bytes - KB                │
│     Access: < 1 ns                  │
├─────────────────────────────────────┤
│     CACHE MEMORY                    │
│     Size: KB - MB                   │
│     Access: 1-10 ns                 │
├─────────────────────────────────────┤
│     MAIN MEMORY (RAM)               │
│     Size: GB                        │
│     Access: 50-100 ns               │
├─────────────────────────────────────┤
│     SECONDARY STORAGE (slowest)     │
│     Size: TB                        │
│     Access: ms                      │
└─────────────────────────────────────┘`
          }
        ]
      },
      {
        id: 'memory-protection',
        title: 'Memory Protection',
        content: `Memory protection prevents processes from accessing memory that doesn't belong to them. This is crucial for system stability and security.`,
        keyPoints: [
          'Base Register: Contains the starting physical address of a process',
          'Limit Register: Contains the size of the process memory',
          'Each memory access is checked: base ≤ address < base + limit',
          'Illegal accesses generate traps/exceptions'
        ],
        examples: [
          {
            title: 'Base and Limit Register Example',
            description: 'How OS protects process memory',
            visual: `
Process A wants address 500:
┌──────────────────────────────┐
│ Base Register: 1000          │
│ Limit Register: 2000         │
└──────────────────────────────┘

Physical Address = 1000 + 500 = 1500 ✓ Valid!
(1000 ≤ 1500 < 3000)

If Process A tries address 3000:
Physical Address = 1000 + 3000 = 4000 ✗ Invalid!
(4000 > 3000) → Segmentation Fault!`
          }
        ]
      },
      {
        id: 'address-binding',
        title: 'Address Binding',
        content: `Address binding is the process of mapping program addresses to actual physical memory addresses. This can happen at different times during program execution.`,
        keyPoints: [
          'Compile Time: If memory location known a priori, absolute code generated',
          'Load Time: If memory location not known at compile time, relocatable code generated',
          'Execution Time: Binding delayed until runtime if process can move during execution'
        ],
        examples: [
          {
            title: 'Address Binding Timeline',
            description: 'When addresses are assigned',
            visual: `
SOURCE CODE → COMPILE → LOAD → EXECUTE
   (symbolic)   (relocatable) (physical)

Example:
Source: jump to "loop"
Compile: jump to 100 (relative)
Load: jump to 1400 (if loaded at 1300)
Execute: actual physical address used`
          }
        ]
      },
      {
        id: 'logical-physical',
        title: 'Logical vs Physical Address Space',
        content: `Logical addresses are generated by the CPU during program execution. Physical addresses are actual locations in memory hardware. The Memory Management Unit (MMU) translates logical to physical addresses.`,
        keyPoints: [
          'Logical Address: Generated by CPU, also called virtual address',
          'Physical Address: Actual address in memory hardware',
          'MMU: Hardware device that maps logical to physical addresses',
          'Relocation Register: Added to logical address to get physical address'
        ],
        examples: [
          {
            title: 'Address Translation Example',
            description: 'MMU in action',
            visual: `
CPU generates: Logical Address 346
              ↓
         ┌────────────┐
         │    MMU     │
         │ Relocation │
         │ Reg: 14000 │
         └────────────┘
              ↓
Physical Address: 14346

Memory:
┌──────────────────┐
│  ...             │
│ 14000: Process A │ ← Start
│ 14346: Data X    │ ← Our location
│  ...             │
│ 16000: Process B │
└──────────────────┘`
          }
        ]
      },
      {
        id: 'loading-linking',
        title: 'Loading and Linking',
        content: `Loading brings programs into memory for execution. Linking combines separate code modules into a single executable program.`,
        keyPoints: [
          'Static Loading: Entire program loaded into memory before execution',
          'Dynamic Loading: Routine loaded only when called (saves memory)',
          'Static Linking: All modules combined before execution',
          'Dynamic Linking: Linking postponed until execution time (DLLs, shared libraries)'
        ],
        examples: [
          {
            title: 'Static vs Dynamic Linking',
            description: 'Library linking comparison',
            visual: `
STATIC LINKING:
Program.exe (10 MB)
├─ Your Code (2 MB)
├─ Library A (5 MB) ← Copied into exe
└─ Library B (3 MB) ← Copied into exe

DYNAMIC LINKING:
Program.exe (2 MB)
└─ Your Code (2 MB)

At Runtime:
├─ Links to → Library A.dll (5 MB) ← Shared
└─ Links to → Library B.dll (3 MB) ← Shared

Benefits: Smaller executables, updates easier`
          }
        ]
      },
      {
        id: 'swapping',
        title: 'Swapping',
        content: `Swapping is a memory management technique where a process can be temporarily swapped out of main memory to a backing store (disk) and brought back into memory for continued execution.`,
        keyPoints: [
          'Swap Out: Move process from memory to disk',
          'Swap In: Move process from disk to memory',
          'Backing Store: Fast disk area for swapped processes',
          'Used when memory is insufficient for all processes',
          'Roll Out/Roll In: Priority-based swapping'
        ],
        examples: [
          {
            title: 'Swapping Example',
            description: 'How OS manages memory pressure',
            visual: `
MAIN MEMORY (4 GB):          DISK (Swap Space):
┌─────────────┐              ┌─────────────┐
│ OS (1 GB)   │              │             │
├─────────────┤              │             │
│ Process A   │ ─── swap ──→ │ Process C   │
├─────────────┤    out       └─────────────┘
│ Process B   │                     ↓
├─────────────┤              ┌─────────────┐
│ Process C   │ ←── swap ─── │             │
└─────────────┘    in         └─────────────┘

When Process D needs memory:
1. Swap out Process C to disk
2. Load Process D into freed space
3. Later, swap Process C back when needed`
          }
        ]
      },
      {
        id: 'contiguous-allocation',
        title: 'Contiguous Memory Allocation',
        content: `In contiguous allocation, each process occupies a single contiguous section of memory. This is the simplest memory allocation scheme.`,
        keyPoints: [
          'Fixed Partitioning: Memory divided into fixed-size partitions',
          'Variable Partitioning: Partitions created dynamically based on process size',
          'Internal Fragmentation: Wasted space within a partition',
          'External Fragmentation: Wasted space between partitions'
        ],
        examples: [
          {
            title: 'Fixed Partitioning Example',
            description: 'Memory divided into fixed blocks',
            visual: `
Memory (1000 KB):
┌──────────────────┐
│ OS (100 KB)      │
├──────────────────┤
│ Partition 1      │ ← 200 KB (Process A: 150 KB)
│ (200 KB)         │   Internal Frag: 50 KB
├──────────────────┤
│ Partition 2      │ ← 200 KB (Process B: 200 KB)
│ (200 KB)         │   Internal Frag: 0 KB
├──────────────────┤
│ Partition 3      │ ← 200 KB (Empty)
│ (200 KB)         │
├──────────────────┤
│ Partition 4      │ ← 300 KB (Process C: 250 KB)
│ (300 KB)         │   Internal Frag: 50 KB
└──────────────────┘

Problem: Process D needs 350 KB
→ Cannot fit despite 200 KB free!`
          }
        ]
      },
      {
        id: 'partition-algorithms',
        title: 'Partition Allocation Algorithms',
        content: `When a process needs memory, the OS must decide which free partition to use. Different algorithms optimize for different goals.`,
        keyPoints: [
          'First Fit: Allocate first hole large enough',
          'Best Fit: Allocate smallest hole large enough',
          'Worst Fit: Allocate largest hole',
          'Next Fit: Like First Fit but starts from last allocation'
        ],
        examples: [
          {
            title: 'Allocation Algorithm Comparison',
            description: 'Process needs 150 KB',
            visual: `
Free Holes: [100KB] [200KB] [300KB] [150KB]

FIRST FIT:
Scan from start → First hole ≥ 150 KB
Result: Allocates 200 KB hole
Speed: Fast (stops early)

BEST FIT:
Check all holes → Smallest ≥ 150 KB
Result: Allocates 150 KB hole
Advantage: Minimizes wasted space

WORST FIT:
Check all holes → Largest hole
Result: Allocates 300 KB hole
Advantage: Leaves larger remaining holes

NEXT FIT:
Like First Fit, but continues from last position
Result: Spreads allocations more evenly`
          }
        ]
      },
      {
        id: 'fragmentation',
        title: 'Fragmentation',
        content: `Fragmentation is wasted memory space that cannot be allocated to processes. It's a major problem in memory management.`,
        keyPoints: [
          'Internal Fragmentation: Wasted space inside allocated regions',
          'External Fragmentation: Free memory scattered in small blocks',
          'Compaction: Shuffle memory contents to place all free memory together',
          'Compaction requires relocation support and is expensive'
        ],
        examples: [
          {
            title: 'Fragmentation Examples',
            description: 'Types of wasted memory',
            visual: `
INTERNAL FRAGMENTATION:
Partition: 200 KB
Process:   150 KB
Wasted:     50 KB (inside partition)
┌──────────────────┐
│ Process (150 KB) │
├──────────────────┤
│ Wasted (50 KB)   │ ← Cannot be used
└──────────────────┘

EXTERNAL FRAGMENTATION:
Memory: [OS][P1-100KB][50KB][P2-150KB][40KB][P3-200KB][60KB]
New Process: 120 KB
Free Space: 50+40+60 = 150 KB total
Problem: No single hole large enough!

AFTER COMPACTION:
Memory: [OS][P1-100KB][P2-150KB][P3-200KB][150KB-FREE]
Now: Can allocate 120 KB from 150 KB free block!`
          }
        ]
      },
      {
        id: 'paging',
        title: 'Paging',
        content: `Paging is a non-contiguous memory allocation technique that eliminates external fragmentation. Physical memory is divided into fixed-size blocks called frames, and logical memory is divided into blocks of the same size called pages.`,
        keyPoints: [
          'Page: Fixed-size block of logical memory (typically 4 KB)',
          'Frame: Fixed-size block of physical memory',
          'Page Table: Maps logical pages to physical frames',
          'No external fragmentation (pages can go anywhere)',
          'Small internal fragmentation (last page only)'
        ],
        examples: [
          {
            title: 'Paging Example',
            description: 'How processes are divided into pages',
            visual: `
LOGICAL MEMORY (Process):      PHYSICAL MEMORY:
┌──────────────┐              ┌──────────────┐
│ Page 0       │──────────────→│ Frame 2      │
├──────────────┤              ├──────────────┤
│ Page 1       │──┐           │ Frame 3      │
├──────────────┤  │           ├──────────────┤
│ Page 2       │──┼──────────→│ Frame 1      │
├──────────────┤  │           ├──────────────┤
│ Page 3       │  └──────────→│ Frame 5      │
└──────────────┘              ├──────────────┤
                              │ Frame 4      │
Page Table:                    └──────────────┘
┌───────┬────────┐
│ Page  │ Frame  │            Advantages:
├───────┼────────┤            ✓ No external fragmentation
│   0   │   2    │            ✓ Easy to allocate
│   1   │   5    │            ✓ Easy to swap
│   2   │   1    │            ✓ Process can be non-contiguous
│   3   │   5    │
└───────┴────────┘`
          },
          {
            title: 'Address Translation in Paging',
            description: 'Converting logical to physical address',
            visual: `
Page Size: 4 KB (4096 bytes)
Logical Address: 8196

Step 1: Split address
Page Number = 8196 / 4096 = 2
Offset = 8196 % 4096 = 4

Step 2: Look up page table
Page 2 → Frame 5

Step 3: Calculate physical address
Physical Address = (Frame × Page Size) + Offset
                 = (5 × 4096) + 4
                 = 20484

┌─────────────────────────────┐
│ Logical Address: 8196       │
├──────────────┬──────────────┤
│ Page: 2      │ Offset: 4    │
└──────────────┴──────────────┘
       ↓ Page Table
┌──────────────┬──────────────┐
│ Frame: 5     │ Offset: 4    │
├──────────────┴──────────────┤
│ Physical Address: 20484     │
└─────────────────────────────┘`
          }
        ]
      },
      {
        id: 'segmentation',
        title: 'Segmentation',
        content: `Segmentation divides the logical address space into variable-length segments based on the logical division of the program (code, data, stack, etc.). Unlike paging, segmentation reflects the program's structure.`,
        keyPoints: [
          'Segment: Variable-length logical unit (code, data, stack, heap)',
          'Segment Table: Maps segments to physical memory',
          'Each entry has base address and limit (length)',
          'Reflects logical program structure',
          'May have external fragmentation'
        ],
        examples: [
          {
            title: 'Segmentation Example',
            description: 'Program divided into logical segments',
            visual: `
LOGICAL VIEW (Program):       PHYSICAL MEMORY:
┌────────────────────┐       ┌────────────────────┐
│ Segment 0: Code    │───────→│ Address 1400       │
│ (1000 bytes)       │       │ Code (1000 bytes)  │
├────────────────────┤       ├────────────────────┤
│ Segment 1: Data    │───┐   │ Other programs     │
│ (500 bytes)        │   │   ├────────────────────┤
├────────────────────┤   └──→│ Address 6300       │
│ Segment 2: Stack   │───┐   │ Data (500 bytes)   │
│ (300 bytes)        │   │   ├────────────────────┤
└────────────────────┘   │   │ Other programs     │
                         │   ├────────────────────┤
Segment Table:           └──→│ Address 4300       │
┌─────┬──────┬───────┐       │ Stack (300 bytes)  │
│ Seg │ Base │ Limit │       └────────────────────┘
├─────┼──────┼───────┤
│  0  │ 1400 │ 1000  │       Benefits:
│  1  │ 6300 │  500  │       ✓ Logical separation
│  2  │ 4300 │  300  │       ✓ Protection per segment
└─────┴──────┴───────┘       ✓ Sharing possible`
          },
          {
            title: 'Address Translation in Segmentation',
            description: 'Converting segment address to physical',
            visual: `
Logical Address: <segment, offset>
Example: <2, 53>

Step 1: Check validity
Segment 2, Offset 53
Limit = 300 bytes
53 < 300? Yes ✓ Valid

Step 2: Calculate physical address
Base = 4300
Physical Address = Base + Offset
                 = 4300 + 53
                 = 4353

If offset ≥ limit → SEGMENTATION FAULT!
Example: <2, 400>
400 ≥ 300 → ERROR!`
          }
        ]
      },
      {
        id: 'seg-with-paging',
        title: 'Segmentation with Paging',
        content: `This combines benefits of both segmentation and paging. Each segment is divided into pages, eliminating external fragmentation while maintaining logical structure.`,
        keyPoints: [
          'Segments divided into pages',
          'Each segment has its own page table',
          'Eliminates external fragmentation',
          'Maintains logical program structure',
          'Used in many modern systems (x86-64)'
        ],
        examples: [
          {
            title: 'Segmentation with Paging',
            description: 'Two-level address translation',
            visual: `
Logical Address: <segment, page, offset>

Example: <1, 2, 100>

Step 1: Segment Table
Segment 1 → Page Table Base Address

Step 2: Page Table (for Segment 1)
Page 2 → Frame 7

Step 3: Physical Address
Frame 7 + Offset 100

┌──────────────────────────────┐
│ Segment Table                │
│ ┌────┬────────────────────┐  │
│ │ 1  │ Page Table Addr    │  │
│ └────┴────────────────────┘  │
└──────────────────────────────┘
              ↓
┌──────────────────────────────┐
│ Page Table (Segment 1)       │
│ ┌────┬────────┐              │
│ │ 2  │ Frame 7│              │
│ └────┴────────┘              │
└──────────────────────────────┘
              ↓
┌──────────────────────────────┐
│ Physical Memory: Frame 7     │
│ + Offset 100                 │
└──────────────────────────────┘`
          }
        ]
      },
      {
        id: 'virtual-memory',
        title: 'Introduction to Virtual Memory',
        content: `Virtual Memory is a memory management technique that allows execution of processes that may not be completely in physical memory. This enables running programs larger than physical memory and provides memory abstraction.`,
        keyPoints: [
          'Separation of logical and physical memory',
          'Only part of program needs to be in memory for execution',
          'Allows more processes in memory (higher multiprogramming)',
          'Programs can be larger than physical memory',
          'Implemented using demand paging or demand segmentation'
        ],
        examples: [
          {
            title: 'Virtual Memory Concept',
            description: 'Running large programs on limited RAM',
            visual: `
VIRTUAL MEMORY (Process View):
┌─────────────────┐ 4 GB Process
│ Page 0          │
│ Page 1          │ ← Only these
│ Page 2          │   pages in RAM
│ ...             │
│ Page 100        │ ← On disk
│ ...             │
│ Page 1000       │
└─────────────────┘

PHYSICAL MEMORY (4 GB RAM):
┌─────────────────┐
│ OS              │
│ Page 0 (Proc A) │ ← Active pages
│ Page 1 (Proc A) │   loaded here
│ Page 5 (Proc B) │
│ Page 2 (Proc A) │
│ ...             │
└─────────────────┘

DISK (Swap Space):
┌─────────────────┐
│ Page 3 (Proc A) │ ← Inactive pages
│ Page 4 (Proc A) │   stored here
│ Page 100        │
│ ...             │
└─────────────────┘

Benefits:
✓ Run 10 GB program on 4 GB RAM
✓ More programs in memory simultaneously
✓ Efficient memory usage`
          }
        ]
      },
      {
        id: 'demand-paging',
        title: 'Demand Paging',
        content: `Demand Paging is a lazy loading technique where pages are loaded into memory only when they are needed (demanded). This is the most common implementation of virtual memory.`,
        keyPoints: [
          'Pages loaded only when accessed (lazy loading)',
          'Valid-Invalid bit tracks if page is in memory',
          'Initially all pages marked invalid',
          'Page fault occurs when accessing invalid page',
          'Reduces memory usage and startup time'
        ],
        examples: [
          {
            title: 'Demand Paging Process',
            description: 'Loading pages on demand',
            visual: `
INITIAL STATE (Program starts):
Page Table:
┌──────┬───────┬───────────┐
│ Page │ Frame │ Valid Bit │
├──────┼───────┼───────────┤
│  0   │  -    │     0     │ ← All invalid
│  1   │  -    │     0     │
│  2   │  -    │     0     │
│  3   │  -    │     0     │
└──────┴───────┴───────────┘

AFTER ACCESSING PAGES 0, 2:
Page Table:
┌──────┬───────┬───────────┐
│ Page │ Frame │ Valid Bit │
├──────┼───────┼───────────┤
│  0   │  5    │     1     │ ← Loaded
│  1   │  -    │     0     │ ← Not accessed
│  2   │  3    │     1     │ ← Loaded
│  3   │  -    │     0     │ ← Not accessed
└──────┴───────┴───────────┘

Physical Memory:
┌──────────────┐
│ Frame 3: P2  │ ← Only accessed
│ Frame 5: P0  │   pages loaded
└──────────────┘

Memory Saved: Pages 1 and 3 not loaded!`
          }
        ]
      },
      {
        id: 'page-fault',
        title: 'Page Fault',
        content: `A page fault occurs when a program accesses a page that is not currently in physical memory. The OS must handle this by loading the required page from disk.`,
        keyPoints: [
          'Trap to OS when accessing invalid page',
          'OS checks if reference is valid',
          'Find free frame or evict a page',
          'Read desired page from disk into frame',
          'Update page table and restart instruction'
        ],
        examples: [
          {
            title: 'Page Fault Handling Steps',
            description: 'What happens during a page fault',
            visual: `
1. PROCESS ACCESSES PAGE 5
   ┌─────────────────┐
   │ Access Page 5   │
   └─────────────────┘
           ↓
   Page Table: Valid Bit = 0
   → PAGE FAULT!

2. TRAP TO OS
   ┌──────────────────┐
   │ CPU → OS Kernel  │
   │ Save process     │
   │ state            │
   └──────────────────┘

3. VALIDATE REFERENCE
   Is Page 5 part of process? Yes ✓

4. FIND FREE FRAME
   ┌──────────────────┐
   │ Check free frame │
   │ list             │
   │ Frame 8 free     │
   └──────────────────┘

5. LOAD PAGE FROM DISK
   ┌──────────────────┐
   │ Disk Read        │
   │ Page 5 →         │
   │ Frame 8          │
   └──────────────────┘
   (This is SLOW: ~5-10 ms)

6. UPDATE PAGE TABLE
   Page 5: Frame 8, Valid = 1

7. RESTART INSTRUCTION
   Now access succeeds!

Time Cost:
Normal access: ~100 nanoseconds
Page fault: ~5 milliseconds
→ 50,000 times slower!`
          }
        ]
      },
      {
        id: 'page-replacement',
        title: 'Page Replacement',
        content: `When memory is full and a page fault occurs, the OS must choose a victim page to remove (replace) to make room for the new page. The goal is to minimize page faults.`,
        keyPoints: [
          'Needed when all frames are allocated',
          'Must choose victim page to evict',
          'Modify (dirty) bit tracks if page changed',
          'Dirty pages must be written to disk',
          'Clean pages can be discarded',
          'Goal: Minimize number of page faults'
        ],
        examples: [
          {
            title: 'Page Replacement Process',
            description: 'Replacing a page when memory is full',
            visual: `
SCENARIO: All frames full, need Page 7

PHYSICAL MEMORY (FULL):
┌──────────────────┐
│ Frame 0: Page 2  │
│ Frame 1: Page 5  │ ← Victim chosen
│ Frame 2: Page 1  │
│ Frame 3: Page 9  │
└──────────────────┘

STEP 1: Select victim page
Algorithm chooses Page 5 (in Frame 1)

STEP 2: Check dirty bit
If modified → Write to disk
If clean → Just discard

STEP 3: Load new page
Read Page 7 from disk → Frame 1

AFTER REPLACEMENT:
┌──────────────────┐
│ Frame 0: Page 2  │
│ Frame 1: Page 7  │ ← New page
│ Frame 2: Page 1  │
│ Frame 3: Page 9  │
└──────────────────┘

STEP 4: Update page tables
Page 5: Invalid
Page 7: Frame 1, Valid

Page Replacement Time:
Clean page: 1 disk read
Dirty page: 1 disk write + 1 disk read
→ Prefer replacing clean pages!`
          }
        ]
      }
    ]
  },
  {
    id: 'unit2',
    title: 'File System',
    hours: 10,
    topics: [
      {
        id: 'file-concept',
        title: 'File Concept',
        content: `A file is a named collection of related information stored on secondary storage. Files are the logical units of storage from a user's perspective.`,
        keyPoints: [
          'File: Named collection of related data',
          'Provides abstraction over physical storage',
          'Persistent storage (survives process termination)',
          'Can be manipulated as a unit'
        ],
        examples: [
          {
            title: 'File Abstraction',
            description: 'How users see files vs physical reality',
            visual: `
USER VIEW:
document.pdf (1.2 MB)

PHYSICAL REALITY:
┌─────────────────────────────┐
│ Disk Blocks: 2056, 2057,    │
│ 2058, 3201, 3202, 5670,     │
│ 5671, 5672...               │
│ (scattered across disk)      │
└─────────────────────────────┘

OS provides abstraction:
✓ Single logical unit
✓ Meaningful name
✓ Hide physical complexity
✓ Sequential view of data`
          }
        ]
      },
      {
        id: 'file-attributes',
        title: 'File Attributes',
        content: `File attributes (metadata) provide information about the file beyond its content. This information is essential for file management.`,
        keyPoints: [
          'Name: Human-readable name',
          'Identifier: Unique tag/number (inode number)',
          'Type: File type information',
          'Location: Pointer to device and location on device',
          'Size: Current file size in bytes',
          'Protection: Access control information',
          'Time stamps: Creation, modification, last access',
          'Owner: User who created/owns the file'
        ],
        examples: [
          {
            title: 'File Attributes Example',
            description: 'Linux file attributes (ls -l)',
            visual: `
$ ls -l document.txt

-rw-r--r-- 1 john staff 2048 Oct 21 10:30 document.txt

Breaking it down:
┌──────────────────────────────────┐
│ -rw-r--r--  → Permissions        │
│   - : Regular file               │
│   rw- : Owner can read/write     │
│   r-- : Group can read           │
│   r-- : Others can read          │
├──────────────────────────────────┤
│ 1 → Number of hard links         │
├──────────────────────────────────┤
│ john → Owner                     │
├──────────────────────────────────┤
│ staff → Group                    │
├──────────────────────────────────┤
│ 2048 → Size in bytes             │
├──────────────────────────────────┤
│ Oct 21 10:30 → Last modified     │
├──────────────────────────────────┤
│ document.txt → File name         │
└──────────────────────────────────┘

File Inode (Internal):
Inode #: 1234567
Disk Blocks: 5001, 5002, 5003
Created: Oct 20 09:15:22
Accessed: Oct 21 11:45:10`
          }
        ]
      },
      {
        id: 'file-operations',
        title: 'File Operations',
        content: `Operating systems provide system calls to perform operations on files. These are the basic operations that can be performed.`,
        keyPoints: [
          'Create: Make new file',
          'Open: Prepare file for access',
          'Read: Read data from file',
          'Write: Write data to file',
          'Reposition (Seek): Move file pointer',
          'Delete: Remove file',
          'Close: Finish using file',
          'Truncate: Reset file to zero length'
        ],
        examples: [
          {
            title: 'File Operations Example',
            description: 'C program demonstrating file operations',
            code: `// File Operations Example in C

#include <stdio.h>
#include <stdlib.h>

int main() {
    FILE *fp;
    char buffer[100];

    // CREATE and OPEN file for writing
    fp = fopen("example.txt", "w");
    if (fp == NULL) {
        printf("Error creating file\\n");
        return 1;
    }

    // WRITE to file
    fprintf(fp, "Hello, File System!\\n");
    fprintf(fp, "This is line 2\\n");

    // CLOSE file
    fclose(fp);

    // OPEN file for reading
    fp = fopen("example.txt", "r");
    if (fp == NULL) {
        printf("Error opening file\\n");
        return 1;
    }

    // READ from file
    printf("File contents:\\n");
    while (fgets(buffer, 100, fp) != NULL) {
        printf("%s", buffer);
    }

    // REPOSITION to beginning
    rewind(fp);

    // READ first line only
    fgets(buffer, 100, fp);
    printf("\\nFirst line: %s", buffer);

    // CLOSE file
    fclose(fp);

    return 0;
}

Output:
File contents:
Hello, File System!
This is line 2

First line: Hello, File System!`
          },
          {
            title: 'File Descriptor Table',
            description: 'OS maintains open file table',
            visual: `
PROCESS FILE DESCRIPTOR TABLE:
┌────┬──────────────────────┐
│ FD │ Pointer              │
├────┼──────────────────────┤
│ 0  │ → stdin              │
│ 1  │ → stdout             │
│ 2  │ → stderr             │
│ 3  │ → example.txt        │ ← Our file
│ 4  │ → data.csv           │
└────┴──────────────────────┘
       ↓
SYSTEM-WIDE OPEN FILE TABLE:
┌──────────────────────────┐
│ File: example.txt        │
│ Inode: 1234567           │
│ Current Position: 0      │ ← File pointer
│ Access Mode: Read        │
│ Reference Count: 1       │
└──────────────────────────┘

After read(3, buffer, 10):
Current Position: 0 → 10 ← Moves forward`
          }
        ]
      },
      {
        id: 'file-types',
        title: 'File Types',
        content: `Operating systems recognize different types of files, each with special handling and purposes.`,
        keyPoints: [
          'Regular Files: Contain user data (text, binary, programs)',
          'Directories: Contain file names and pointers to other files',
          'Character Special Files: Model serial I/O devices (terminals, printers)',
          'Block Special Files: Model block devices (disks)',
          'Links: Point to other files (hard links, symbolic links)',
          'Sockets: Used for network communication',
          'Pipes: Used for inter-process communication'
        ],
        examples: [
          {
            title: 'File Types in Unix/Linux',
            description: 'Different file types and their identifiers',
            visual: `
$ ls -l /dev/

crw-rw-rw-  1 root tty    5,  0 Oct 21 10:00 tty
brw-rw----  1 root disk   8,  0 Oct 21 10:00 sda
drwxr-xr-x  2 root root   4096 Oct 21 10:00 input/
lrwxrwxrwx  1 root root     15 Oct 21 10:00 stdout → /proc/self/fd/1
prw-r--r--  1 john staff     0 Oct 21 10:00 mypipe
srwxrwxrwx  1 root root      0 Oct 21 10:00 socket

First character indicates type:
┌──────┬────────────────────────────┐
│ -    │ Regular file               │
│ d    │ Directory                  │
│ c    │ Character special file     │
│ b    │ Block special file         │
│ l    │ Symbolic link              │
│ p    │ Named pipe (FIFO)          │
│ s    │ Socket                     │
└──────┴────────────────────────────┘

EXAMPLES:
Regular: document.txt, program.exe
Directory: /home/john/
Character: /dev/tty (terminal)
Block: /dev/sda (hard disk)
Link: /usr/bin/python → /usr/bin/python3.9
Pipe: Used for: cat file.txt | grep "error"
Socket: /var/run/docker.sock`
          }
        ]
      },
      {
        id: 'file-extension',
        title: 'File Extensions',
        content: `File extensions are suffixes added to filenames to indicate the file type or format. While the OS may not require them, they help users and applications identify file content.`,
        keyPoints: [
          'Convention, not requirement (in Unix/Linux)',
          'Windows relies heavily on extensions',
          'Helps applications know how to handle files',
          'Common extensions: .txt, .pdf, .jpg, .exe, .html'
        ],
        examples: [
          {
            title: 'Common File Extensions',
            description: 'File extensions by category',
            visual: `
TEXT FILES:
.txt  → Plain text
.doc  → Microsoft Word
.pdf  → Portable Document Format
.rtf  → Rich Text Format

IMAGES:
.jpg  → JPEG image
.png  → Portable Network Graphics
.gif  → Graphics Interchange Format
.svg  → Scalable Vector Graphics

AUDIO:
.mp3  → MPEG Audio
.wav  → Waveform Audio
.flac → Free Lossless Audio

VIDEO:
.mp4  → MPEG-4 video
.avi  → Audio Video Interleave
.mkv  → Matroska video

COMPRESSED:
.zip  → ZIP archive
.tar  → Tape archive
.gz   → GNU zip

EXECUTABLE:
.exe  → Windows executable
.sh   → Shell script
.py   → Python script
.jar  → Java archive

How OS uses extensions:
1. Double-click file.pdf
2. OS checks extension
3. Launches associated app (Adobe Reader)
4. App opens file`
          }
        ]
      },
      {
        id: 'file-structure',
        title: 'File Structure',
        content: `Files can be organized internally in different ways. The structure determines how data is arranged within the file.`,
        keyPoints: [
          'Unstructured: Sequence of bytes (Unix approach)',
          'Simple Record Structure: Fixed-length records',
          'Complex Structure: Indexed, tree-structured (databases)',
          'OS may enforce structure or leave it to applications'
        ],
        examples: [
          {
            title: 'File Structure Types',
            description: 'Different internal file organizations',
            visual: `
1. UNSTRUCTURED (Byte Sequence):
┌─────────────────────────────────┐
│ 0x48 0x65 0x6C 0x6C 0x6F 0x20...│
│ (just bytes, no structure)       │
└─────────────────────────────────┘
Example: Plain text files
Application interprets meaning

2. SIMPLE RECORD STRUCTURE:
┌──────────────────────────────┐
│ Record 1 (100 bytes)         │
├──────────────────────────────┤
│ Record 2 (100 bytes)         │
├──────────────────────────────┤
│ Record 3 (100 bytes)         │
└──────────────────────────────┘
Example: Employee database
Each record: ID(10) + Name(50) + Salary(10) + Department(30)

3. COMPLEX STRUCTURE:
┌──────────────────────────────┐
│ Header: Index location       │
├──────────────────────────────┤
│ Data Records (variable)      │
│  Record A (150 bytes)        │
│  Record B (200 bytes)        │
│  Record C (175 bytes)        │
├──────────────────────────────┤
│ Index: B-tree structure      │
│  Key → Record location       │
└──────────────────────────────┘
Example: Database files, indexed files

CSV FILE (Simple Structure):
ID,Name,Age,Salary
101,John,30,50000
102,Jane,25,55000
103,Bob,35,60000

BINARY FILE (Complex Structure):
[4-byte int][50-byte string][4-byte float]...`
          }
        ]
      },
      {
        id: 'access-methods',
        title: 'File Access Methods',
        content: `Access methods determine how programs can access the data stored in files.`,
        keyPoints: [
          'Sequential Access: Read/write sequentially from beginning',
          'Direct Access (Random Access): Read/write any block directly',
          'Indexed Access: Use index to find records quickly'
        ],
        examples: [
          {
            title: 'Sequential Access',
            description: 'Reading file from start to end',
            visual: `
SEQUENTIAL ACCESS:
File: [A][B][C][D][E][F][G][H]
       ↑
     Start

Operations:
read() → A
read() → B
read() → C
...must read in order

Example: Log files, tape backups
┌──────────────────────────────┐
│ Current Position: 0          │
│ read() → Position: 1         │
│ read() → Position: 2         │
│ read() → Position: 3         │
└──────────────────────────────┘

Use Case: Processing entire file
while (read(buffer) != EOF) {
    process(buffer);
}

Advantage: Simple, works on any medium
Disadvantage: Slow for random access`
          },
          {
            title: 'Direct Access (Random Access)',
            description: 'Jump to any position',
            visual: `
DIRECT ACCESS:
File: [A][B][C][D][E][F][G][H]
       0  1  2  3  4  5  6  7

Operations:
seek(5) → Position: 5
read() → F
seek(2) → Position: 2
read() → C

Example: Database files, virtual memory
┌──────────────────────────────┐
│ seek(position)               │
│ read(block_number)           │
│ write(block_number, data)    │
└──────────────────────────────┘

Code Example:
// Read block 100
lseek(fd, 100 * BLOCK_SIZE, SEEK_SET);
read(fd, buffer, BLOCK_SIZE);

// Read block 50
lseek(fd, 50 * BLOCK_SIZE, SEEK_SET);
read(fd, buffer, BLOCK_SIZE);

Advantage: Fast access to any position
Disadvantage: Requires disk (not tape)

Real Example: Video player
User seeks to 45:30 → Directly access that block`
          },
          {
            title: 'Indexed Access',
            description: 'Using index for quick lookup',
            visual: `
INDEXED ACCESS:

INDEX TABLE:
┌──────────┬──────────────┐
│   Key    │   Position   │
├──────────┼──────────────┤
│ "Alice"  │    0         │
│ "Bob"    │   150        │
│ "Carol"  │   420        │
│ "Dave"   │   680        │
└──────────┴──────────────┘
      ↓ Search index
DATA FILE:
┌──────────────────────────┐
│ 0: Alice|Age:30|...      │
├──────────────────────────┤
│ 150: Bob|Age:25|...      │
├──────────────────────────┤
│ 420: Carol|Age:35|...    │
├──────────────────────────┤
│ 680: Dave|Age:28|...     │
└──────────────────────────┘

Search for "Carol":
1. Look up "Carol" in index → Position 420
2. Seek to position 420
3. Read data

Advantage: Very fast lookups (O(log n))
Use Case: Large databases, phone books

Without Index:
Must read sequentially until found (slow)

With Index:
Direct jump to location (fast)`
          }
        ]
      },
      {
        id: 'file-protection',
        title: 'File Protection',
        content: `File systems must protect files from unauthorized access. Protection mechanisms control who can access files and what operations they can perform.`,
        keyPoints: [
          'Read: View file contents',
          'Write: Modify file contents',
          'Execute: Run file as program',
          'Append: Add to end of file',
          'Delete: Remove file',
          'List: View file attributes'
        ],
        examples: [
          {
            title: 'Types of Access',
            description: 'File permissions',
            visual: `
UNIX FILE PERMISSIONS:

rwx rwx rwx
│││ │││ │││
│││ │││ │└└── Others: Execute
│││ │││ └──── Others: Write
│││ ││└────── Others: Read
│││ ││
│││ │└────── Group: Execute
│││ └─────── Group: Write
││└───────── Group: Read
││
│└────────── Owner: Execute
└─────────── Owner: Write
────────────── Owner: Read

EXAMPLE: rw-r--r--
Owner:  Read, Write
Group:  Read only
Others: Read only

NUMERIC REPRESENTATION:
Read (r)    = 4
Write (w)   = 2
Execute (x) = 1

rw-r--r-- = 644
rwxr-xr-x = 755
rwx------ = 700

$ chmod 755 script.sh
Owner: rwx (7 = 4+2+1)
Group: r-x (5 = 4+1)
Others: r-x (5 = 4+1)`
          },
          {
            title: 'Access Control Lists (ACL)',
            description: 'Fine-grained permissions',
            visual: `
TRADITIONAL (3 classes):
Owner, Group, Others

ACCESS CONTROL LIST (flexible):
┌──────────────────────────────┐
│ User: alice → rw-            │
│ User: bob → r--              │
│ User: charlie → rwx          │
│ Group: developers → rw-      │
│ Group: managers → r--        │
│ Default → ---                │
└──────────────────────────────┘

Example (Linux):
$ getfacl document.txt
# file: document.txt
# owner: alice
# group: staff
user::rw-
user:bob:r--
user:charlie:rwx
group::r--
group:developers:rw-
mask::rwx
other::---

$ setfacl -m u:bob:rw document.txt
# Give bob read-write access

Benefits:
✓ More flexible than owner/group/other
✓ Can specify permissions per user
✓ Can specify permissions per group
✓ Can set default permissions for new files`
          },
          {
            title: 'Access Control Example',
            description: 'Real-world scenario',
            visual: `
COMPANY FILE SERVER:

/projects/secret_project/
├── design.pdf
├── code.zip
└── budget.xlsx

REQUIREMENTS:
1. Project lead (Alice): Full access
2. Developers (Bob, Carol): Read/write code
3. Finance (Dave): Read budget only
4. Others: No access

PERMISSIONS SETUP:

design.pdf:
Owner: alice (rwx)
Group: project_team (rw-)
ACL: dave (---)
Others: (---)

code.zip:
Owner: alice (rwx)
Group: developers (rw-)
ACL: bob (rw-), carol (rw-)
Others: (---)

budget.xlsx:
Owner: alice (rwx)
Group: finance (r--)
ACL: dave (r--)
Others: (---)

SECURITY PRINCIPLE:
Least Privilege: Users get minimum access needed

Result:
✓ Alice: Access all files
✓ Bob & Carol: Access code only
✓ Dave: Read budget only
✓ Outsiders: No access`
          }
        ]
      }
    ]
  },
  {
    id: 'unit3',
    title: 'Linux Operating System',
    hours: 15,
    topics: [
      {
        id: 'linux-history',
        title: 'History of Linux',
        content: `Linux is a free and open-source Unix-like operating system kernel created by Linus Torvalds in 1991. It has grown into one of the most widely used operating systems worldwide.`,
        keyPoints: [
          '1969: Unix created at AT&T Bell Labs',
          '1983: GNU Project started by Richard Stallman',
          '1991: Linux kernel created by Linus Torvalds (age 21)',
          '1992: Linux released under GPL (GNU General Public License)',
          '1990s-2000s: Rapid growth, enterprise adoption',
          'Today: Powers 90%+ of cloud servers, Android devices, supercomputers'
        ],
        examples: [
          {
            title: 'Linux Timeline',
            description: 'Key milestones in Linux history',
            visual: `
1969: UNIX born (Bell Labs)
  │
1983: GNU Project (Stallman)
  │   Goal: Free Unix-like OS
  │
1991: Linux kernel 0.01 (Torvalds)
  │   "Just a hobby, won't be big"
  │
1992: Linux + GNU = GNU/Linux
  │   Complete free OS
  │
1993: Debian founded
1994: Red Hat founded
  │
1998: IBM announces Linux support
  │   Enterprise validation
  │
2000s: Linux on servers, phones
2008: Android (Linux kernel)
  │
2010s: Cloud computing dominance
  │   AWS, Google, Azure run Linux
  │
2020s: Linux everywhere
  │   Servers, phones, IoT, cars
  │   90%+ of cloud infrastructure

WHY LINUX SUCCEEDED:
✓ Free and open-source
✓ Highly customizable
✓ Excellent community support
✓ Stable and secure
✓ Runs on any hardware
✓ Powers innovation`
          },
          {
            title: 'Linux Distributions',
            description: 'Popular Linux flavors',
            visual: `
LINUX KERNEL + GNU TOOLS + APPS = DISTRIBUTION

MAJOR FAMILIES:

Debian-based:
├── Debian (stable, community)
├── Ubuntu (user-friendly)
│   ├── Linux Mint
│   └── Pop!_OS
└── Kali Linux (security)

Red Hat-based:
├── RHEL (enterprise)
├── Fedora (cutting-edge)
└── CentOS (free RHEL)

Arch-based:
├── Arch Linux (DIY)
└── Manjaro (user-friendly)

Independent:
├── Gentoo (compile from source)
└── Slackware (oldest)

USE CASES:
Ubuntu → Beginners, developers
Debian → Servers, stability
Fedora → Latest features
RHEL/CentOS → Enterprise
Arch → Advanced users
Kali → Security testing

Market Share (Servers):
Ubuntu: ~34%
Debian: ~16%
CentOS: ~20%
Others: ~30%`
          }
        ]
      },
      {
        id: 'linux-design',
        title: 'Linux Design Principles',
        content: `Linux follows the Unix philosophy and incorporates modern operating system design principles focused on simplicity, modularity, and efficiency.`,
        keyPoints: [
          'Monolithic kernel with modular design',
          'Everything is a file (devices, processes, etc.)',
          'Small, focused tools that do one thing well',
          'Shell scripts combine tools for complex tasks',
          'Portability across different hardware',
          'Open source and collaborative development'
        ],
        examples: [
          {
            title: 'Linux Architecture',
            description: 'Layered structure',
            visual: `
┌─────────────────────────────────────┐
│        USER APPLICATIONS            │
│  (Firefox, Office, Games, etc.)     │
├─────────────────────────────────────┤
│         SYSTEM LIBRARIES            │
│  (glibc, GTK, Qt, OpenGL, etc.)     │
├─────────────────────────────────────┤
│       SYSTEM CALL INTERFACE         │
│  (open, read, write, fork, etc.)    │
├─────────────────────────────────────┤
│         LINUX KERNEL                │
│  ┌─────────────────────────────┐   │
│  │   Process Management        │   │
│  │   Memory Management         │   │
│  │   File Systems              │   │
│  │   Device Drivers            │   │
│  │   Network Stack             │   │
│  │   Security (SELinux)        │   │
│  └─────────────────────────────┘   │
├─────────────────────────────────────┤
│           HARDWARE                  │
│  (CPU, RAM, Disk, Network, etc.)    │
└─────────────────────────────────────┘

KEY FEATURES:
1. Preemptive multitasking
2. Virtual memory with paging
3. Loadable kernel modules
4. Symmetric multiprocessing (SMP)
5. POSIX compliant
6. Networking built-in`
          },
          {
            title: 'Everything is a File',
            description: 'Unix philosophy in Linux',
            visual: `
UNIFIED INTERFACE: File operations work on everything

REGULAR FILES:
/home/user/document.txt → User data

DIRECTORIES:
/home/user/ → Special file listing other files

DEVICE FILES:
/dev/sda → Hard disk (block device)
/dev/tty → Terminal (character device)
/dev/null → Bit bucket (discard data)
/dev/random → Random number generator

PROCESS INFO:
/proc/1234/status → Process 1234 status
/proc/cpuinfo → CPU information
/proc/meminfo → Memory information

SYSTEM INFO:
/sys/class/net/eth0/ → Network interface

EXAMPLES:

Read CPU info:
$ cat /proc/cpuinfo

Write to device:
$ echo "Hello" > /dev/tty1

Discard output:
$ command > /dev/null

Random data:
$ head -c 10 /dev/random

Benefit: Same operations (open, read, write, close)
work on files, devices, processes!`
          }
        ]
      },
      {
        id: 'kernel-modules',
        title: 'Kernel Modules',
        content: `Linux kernel modules are pieces of code that can be loaded and unloaded into the kernel on demand. They extend kernel functionality without rebooting.`,
        keyPoints: [
          'Loadable Kernel Modules (LKM) extend kernel functionality',
          'Add drivers, file systems, system calls dynamically',
          'No need to reboot to add/remove functionality',
          'Reduce base kernel size (load only what\'s needed)',
          'Can be proprietary (though controversial)'
        ],
        examples: [
          {
            title: 'Kernel Module Commands',
            description: 'Managing kernel modules',
            code: `# List loaded modules
$ lsmod
Module                  Size  Used by
ext4                  614400  2
nvidia              12304384  43
bluetooth             516096  5
usb_storage            69632  0

# Get module information
$ modinfo bluetooth
filename:       /lib/modules/.../bluetooth.ko
description:    Bluetooth subsystem
license:        GPL
depends:        rfkill,crc16

# Load a module
$ sudo modprobe usb_storage
# Or
$ sudo insmod /path/to/module.ko

# Remove a module
$ sudo modprobe -r usb_storage
# Or
$ sudo rmmod usb_storage

# Check module dependencies
$ modprobe --show-depends ext4
insmod /lib/modules/.../mbcache.ko
insmod /lib/modules/.../jbd2.ko
insmod /lib/modules/.../ext4.ko`
          },
          {
            title: 'Kernel Module Architecture',
            description: 'How modules integrate with kernel',
            visual: `
LINUX KERNEL (Running):
┌──────────────────────────────┐
│  Core Kernel                 │
│  ├─ Process Manager          │
│  ├─ Memory Manager           │
│  └─ Scheduler                │
├──────────────────────────────┤
│  Loaded Modules:             │
│  ┌────────────────────────┐  │
│  │ ext4 filesystem        │  │
│  └────────────────────────┘  │
│  ┌────────────────────────┐  │
│  │ nvidia driver          │  │
│  └────────────────────────┘  │
│  ┌────────────────────────┐  │
│  │ bluetooth stack        │  │
│  └────────────────────────┘  │
└──────────────────────────────┘

AVAILABLE MODULES (Not loaded):
/lib/modules/5.15.0/kernel/
├── drivers/
│   ├── usb/storage/
│   ├── gpu/drm/
│   └── net/wireless/
├── fs/
│   ├── ntfs/
│   └── btrfs/
└── net/
    └── netfilter/

LOADING SEQUENCE:
1. modprobe nvidia
2. Check dependencies
3. Load dependencies first
4. Load nvidia module
5. Call module's init() function
6. Module registers with kernel
7. Module ready to use

BENEFITS:
✓ Smaller kernel in memory
✓ Add hardware support without reboot
✓ Easy driver updates
✓ Modular development`
          }
        ]
      },
      {
        id: 'linux-process',
        title: 'Process Management in Linux',
        content: `Linux process management handles creation, scheduling, and termination of processes. Each process has a unique PID and inherits from a parent process.`,
        keyPoints: [
          'Process: Program in execution with PID',
          'Fork: Create child process (copy of parent)',
          'Exec: Replace process image with new program',
          'Init (PID 1): First process, parent of all',
          'Zombie: Terminated but not cleaned up',
          'Orphan: Parent terminated, adopted by init'
        ],
        examples: [
          {
            title: 'Process Creation (fork)',
            description: 'How processes are created',
            code: `#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid;

    printf("Before fork: PID = %d\\n", getpid());

    // Create child process
    pid = fork();

    if (pid < 0) {
        // Fork failed
        printf("Fork failed!\\n");
        return 1;
    }
    else if (pid == 0) {
        // Child process
        printf("Child: PID = %d, Parent = %d\\n",
               getpid(), getppid());
    }
    else {
        // Parent process
        printf("Parent: PID = %d, Child = %d\\n",
               getpid(), pid);
    }

    return 0;
}

Output:
Before fork: PID = 1234
Parent: PID = 1234, Child = 1235
Child: PID = 1235, Parent = 1234`,
            visual: `
BEFORE FORK:
┌────────────────────┐
│ Parent Process     │
│ PID: 1234          │
│ Code, Data, Stack  │
└────────────────────┘

AFTER FORK:
┌────────────────────┐
│ Parent Process     │
│ PID: 1234          │
│ Returns: 1235      │ ← Child's PID
└────────────────────┘
         │
         │ fork() creates copy
         ↓
┌────────────────────┐
│ Child Process      │
│ PID: 1235          │
│ Returns: 0         │ ← 0 indicates child
└────────────────────┘

Both processes continue execution!`
          },
          {
            title: 'Process States',
            description: 'Linux process lifecycle',
            visual: `
PROCESS STATE DIAGRAM:

    NEW
     │
     ↓
 ┌─READY◄──────┐
 │   │         │
 │   │ Dispatch│
 │   ↓         │
 │ RUNNING    │ Preempt/Interrupt
 │   │         │
 │   │ I/O or  │
 │   │ Event   │
 │   ↓         │
 └►WAITING─────┘
     │
     │ Event completion
     ↓
 TERMINATED

STATES EXPLAINED:

NEW (Created):
Process being created

READY (Runnable):
Ready to run, waiting for CPU
$ ps aux | grep "R"

RUNNING:
Currently executing on CPU
Only one per CPU core

WAITING (Sleeping):
Waiting for I/O or event
- Interruptible sleep (S)
- Uninterruptible sleep (D)

STOPPED:
Suspended, can be resumed
Ctrl+Z stops a process

ZOMBIE:
Terminated, waiting for parent
to read exit status
$ ps aux | grep "Z"

PROCESS COMMANDS:
$ ps aux          # List all processes
$ pstree          # Process tree
$ top             # Real-time monitor
$ kill -9 PID     # Force kill
$ killall name    # Kill by name
$ nice -n 10 cmd  # Run with priority`
          }
        ]
      },
      {
        id: 'linux-scheduling',
        title: 'Process Scheduling in Linux',
        content: `Linux uses the Completely Fair Scheduler (CFS) to allocate CPU time fairly among processes. It aims to maximize overall CPU utilization while ensuring fairness.`,
        keyPoints: [
          'CFS: Completely Fair Scheduler (default since 2.6.23)',
          'Red-Black tree for efficient process selection',
          'Virtual runtime (vruntime) tracks CPU time',
          'Scheduling classes: Real-time, CFS, Idle',
          'Nice values (-20 to 19) adjust priority',
          'Real-time scheduling for critical tasks'
        ],
        examples: [
          {
            title: 'Completely Fair Scheduler',
            description: 'How Linux schedules processes',
            visual: `
GOAL: Each process gets fair share of CPU

VIRTUAL RUNTIME (vruntime):
Tracks how much CPU time process has used
Lower vruntime = Less CPU time = Higher priority

RED-BLACK TREE (sorted by vruntime):
          ┌──[P3: 100]──┐
          │             │
     [P1: 50]      [P5: 150]
          │             │
     [P2: 75]      [P4: 125]

Leftmost node = Next to run
(P1 has lowest vruntime)

SCHEDULING STEPS:
1. Pick leftmost process (P1)
2. Run P1 for time slice
3. Update P1's vruntime
4. Insert P1 back into tree
5. Pick new leftmost process
6. Repeat

EXAMPLE:
Time: 0ms
Tree: [P1:0] [P2:0] [P3:0]

After P1 runs 10ms:
Tree: [P2:0] [P3:0] [P1:10]
Next: P2

After P2 runs 10ms:
Tree: [P3:0] [P1:10] [P2:10]
Next: P3

Result: All processes get equal time!`
          },
          {
            title: 'Process Priority',
            description: 'Nice values and priorities',
            visual: `
NICE VALUES: -20 (highest) to 19 (lowest)
Default: 0

┌─────────────────────────────────┐
│ Nice  │ Priority │ CPU Share    │
├───────┼──────────┼──────────────┤
│  -20  │ Highest  │ Most CPU     │
│  -10  │ High     │ More CPU     │
│    0  │ Normal   │ Normal       │
│   10  │ Low      │ Less CPU     │
│   19  │ Lowest   │ Least CPU    │
└─────────────────────────────────┘

COMMANDS:
# Run with nice value
$ nice -n 10 ./program
$ nice -n -5 ./important_program

# Change running process
$ renice 10 -p 1234

# View priorities
$ ps -el
F S   UID   PID  PPRI  NI
0 S  1000  1234   80   0  ← Normal
0 S  1000  1235   90  10  ← Lower
0 S  1000  1236   70 -10  ← Higher

REAL-TIME SCHEDULING:
SCHED_FIFO: First-In-First-Out
SCHED_RR: Round-Robin
Priority: 1-99 (higher = more important)

$ chrt -f 50 ./realtime_app
# Run with FIFO, priority 50

USE CASES:
Nice -20: Critical system tasks
Nice 0:   Normal applications
Nice 19:  Background jobs, batch processing

EXAMPLE:
# Background video encoding
$ nice -n 19 ffmpeg -i input.mp4 output.mp4

# Keeps system responsive while encoding!`
          }
        ]
      },
      {
        id: 'linux-memory',
        title: 'Memory Management in Linux',
        content: `Linux uses virtual memory with demand paging, allowing efficient use of physical RAM and enabling processes to use more memory than physically available.`,
        keyPoints: [
          'Virtual memory for every process',
          'Demand paging with page fault handling',
          'Page cache for disk I/O optimization',
          'Swap space for overflow to disk',
          'Memory mapped files',
          'OOM killer when memory exhausted'
        ],
        examples: [
          {
            title: 'Linux Virtual Memory Layout',
            description: 'Process address space',
            visual: `
64-BIT PROCESS ADDRESS SPACE:

0xFFFFFFFFFFFFFFFF ┌──────────────────┐
                   │ Kernel Space     │
                   │ (System only)    │
0xFFFF800000000000 ├──────────────────┤
                   │                  │
                   │ (Unmapped)       │
                   │                  │
0x7FFFFFFFFFFF     ├──────────────────┤
                   │ Stack            │ ← grows down
                   │ (local vars)     │
                   ├──────────────────┤
                   │       ↓          │
                   │                  │
                   │       ↑          │
                   ├──────────────────┤
                   │ Heap             │ ← grows up
                   │ (malloc)         │
                   ├──────────────────┤
                   │ BSS (uninitialized)
                   ├──────────────────┤
                   │ Data (initialized)
                   ├──────────────────┤
                   │ Text (code)      │
0x400000           └──────────────────┘

VIEW PROCESS MEMORY:
$ cat /proc/1234/maps

400000-400500 r-xp  ...  /bin/program  ← Code
600000-601000 rw-p  ...  /bin/program  ← Data
7fff00-7fff80 rw-p  ...  [stack]       ← Stack
7f8000-7f9000 r-xp  ...  libc.so       ← Library`
          },
          {
            title: 'Memory Management Commands',
            description: 'Monitoring memory usage',
            code: `# View memory usage
$ free -h
              total   used   free   shared   buff/cache   available
Mem:           16Gi   4.2Gi  8.1Gi    234Mi        3.7Gi       11Gi
Swap:         8.0Gi      0B  8.0Gi

# Detailed memory info
$ cat /proc/meminfo
MemTotal:       16384000 kB
MemFree:         8400000 kB
MemAvailable:   11500000 kB
Buffers:          500000 kB
Cached:          3200000 kB
SwapTotal:       8192000 kB
SwapFree:        8192000 kB

# Process memory usage
$ ps aux --sort=-%mem | head
USER       PID %CPU %MEM    VSZ   RSS
chrome    1234  5.2 15.3 4500000 2500000
firefox   5678  3.1 12.1 3800000 1980000

VSZ: Virtual memory size (total allocated)
RSS: Resident Set Size (physical RAM used)

# Top memory consumers
$ top
  PID USER   %CPU %MEM    VSZ   RSS COMMAND
 1234 john    2.5 15.3   4.5G  2.5G chrome
 5678 jane    1.2 12.1   3.8G  2.0G firefox

# Memory map of process
$ pmap 1234
1234:   /usr/bin/program
Address           Size  Perm   Mapping
0000000000400000   4K   r-x--  program
0000000000600000   4K   rw---  program
00007fff12340000 132K   rw---  [ stack ]`,
            visual: `
PAGE CACHE:
When reading files, Linux caches pages in RAM

First read:  Disk → RAM → Process (SLOW)
Second read: RAM → Process (FAST!)

$ free -h
Mem:   total: 16G
       used:   4G   ← Applications
       cache:  8G   ← File cache
       free:   4G   ← Truly free

Cache is automatically freed if needed!

SWAP:
When RAM is full:
1. Identify least-used pages
2. Write to swap (disk)
3. Free RAM for new pages

$ swapon --show
NAME      SIZE USED
/dev/sda2  8G   0B

OOM KILLER:
When out of memory:
1. Try to free cache
2. Try to swap
3. If still no memory → Kill process!

Killed by OOM:
$ dmesg | grep -i oom
Out of memory: Killed process 1234 (chrome)`
          }
        ]
      },
      {
        id: 'linux-filesystem',
        title: 'Linux File Systems',
        content: `Linux supports various file systems and uses a unified directory tree. All storage devices are mounted into a single hierarchy starting at root (/).`,
        keyPoints: [
          'VFS (Virtual File System) provides unified interface',
          'ext4: Default Linux file system',
          'Other FS: XFS, Btrfs, NTFS, FAT32, etc.',
          'Mounting: Attaching file systems to directory tree',
          'Inodes: Data structure for file metadata',
          'Journaling: Protects against corruption'
        ],
        examples: [
          {
            title: 'Linux Directory Structure',
            description: 'Standard directory hierarchy',
            visual: `
ROOT DIRECTORY TREE:

/ (root)
├── bin/          → Essential user binaries
│   ├── ls, cp, mv, cat, bash
│   └── ...
├── boot/         → Boot loader files, kernel
│   └── vmlinuz, initrd
├── dev/          → Device files
│   ├── sda (hard disk)
│   ├── tty (terminals)
│   └── null
├── etc/          → System configuration
│   ├── passwd (users)
│   ├── fstab (mount points)
│   └── network/
├── home/         → User home directories
│   ├── john/
│   └── jane/
├── lib/          → Shared libraries
│   └── libc.so
├── media/        → Removable media mount points
│   ├── usb/
│   └── cdrom/
├── mnt/          → Temporary mount points
├── opt/          → Optional software
├── proc/         → Process and kernel info (virtual)
│   ├── cpuinfo
│   ├── meminfo
│   └── 1234/ (process)
├── root/         → Root user home
├── sbin/         → System binaries
│   └── fsck, reboot, iptables
├── srv/          → Service data
├── sys/          → System info (virtual)
├── tmp/          → Temporary files
├── usr/          → User programs
│   ├── bin/
│   ├── lib/
│   ├── local/
│   └── share/
└── var/          → Variable data
    ├── log/      → Log files
    ├── www/      → Web server data
    └── tmp/      → Temporary files

NAVIGATION:
$ cd /etc           # Absolute path
$ cd ../home/john   # Relative path
$ pwd               # Print working directory
$ ls -la            # List files with details`
          },
          {
            title: 'File System Types',
            description: 'Common Linux file systems',
            visual: `
EXT4 (Fourth Extended Filesystem):
✓ Default Linux file system
✓ Journaling (crash recovery)
✓ Max file size: 16 TB
✓ Max volume size: 1 EB
✓ Backward compatible with ext2/ext3

XFS:
✓ High-performance
✓ Large file support
✓ Good for parallel I/O
✓ Used by RHEL default

BTRFS (B-tree FS):
✓ Copy-on-write
✓ Built-in RAID
✓ Snapshots
✓ Compression
✓ Still maturing

FAT32:
✓ USB drives
✓ Compatibility with Windows
✓ No permissions
✓ Max file: 4 GB

NTFS:
✓ Windows file system
✓ Read/write support in Linux
✓ Requires ntfs-3g driver

MOUNTING:
$ sudo mount /dev/sdb1 /mnt/usb
$ df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1       100G   45G   50G  48% /
/dev/sdb1        32G    5G   27G  16% /mnt/usb

$ cat /etc/fstab
# Automatic mounting at boot
UUID=xxx-xxx  /      ext4  defaults  0 1
UUID=yyy-yyy  /home  ext4  defaults  0 2
/dev/sdb1     /mnt/usb auto noauto  0 0`
          },
          {
            title: 'Inodes',
            description: 'File metadata structure',
            visual: `
INODE: Data structure containing file metadata

INODE STRUCTURE:
┌──────────────────────────────┐
│ Inode Number: 1234567        │
├──────────────────────────────┤
│ File Type: Regular file      │
│ Permissions: rw-r--r--       │
│ Owner: UID 1000              │
│ Group: GID 1000              │
│ Size: 2048 bytes             │
│ Timestamps:                  │
│   Created:  Oct 20 10:00     │
│   Modified: Oct 21 15:30     │
│   Accessed: Oct 21 16:45     │
│ Link Count: 2                │
│ Block Pointers:              │
│   Direct: [5001, 5002, ...]  │
│   Indirect: [6000]           │
│   Double Indirect: [7000]    │
└──────────────────────────────┘

FILE NAME IS NOT IN INODE!
File names stored in directory entries

DIRECTORY ENTRY:
┌────────────┬────────────┐
│  Filename  │ Inode #    │
├────────────┼────────────┤
│ document   │  1234567   │
│ report.txt │  1234568   │
│ data.csv   │  1234569   │
└────────────┴────────────┘

HARD LINKS:
Multiple directory entries → Same inode
$ ln file.txt file2.txt
Both point to same inode!
Link count: 2

SYMBOLIC LINKS:
Special file pointing to another file
$ ln -s file.txt link.txt
link.txt has own inode, contains path

VIEWING INODES:
$ ls -i
1234567 document
1234568 report.txt

$ stat document
  File: document
  Size: 2048
  Inode: 1234567
  Links: 1
Modify: Oct 21 15:30`
          }
        ]
      },
      {
        id: 'linux-io',
        title: 'Input/Output in Linux',
        content: `Linux I/O system provides uniform interface for accessing devices. All I/O operations use the same system calls regardless of device type.`,
        keyPoints: [
          'Block devices: Random access (disks)',
          'Character devices: Stream access (terminals, serial)',
          'Device drivers handle hardware specifics',
          'Buffering and caching for performance',
          'I/O scheduling algorithms',
          'Standard streams: stdin, stdout, stderr'
        ],
        examples: [
          {
            title: 'Standard I/O Streams',
            description: 'File descriptors 0, 1, 2',
            visual: `
EVERY PROCESS HAS 3 STANDARD STREAMS:

┌────────────────────────────────┐
│ File Descriptor 0: stdin       │ ← Keyboard input
│ File Descriptor 1: stdout      │ → Screen output
│ File Descriptor 2: stderr      │ → Error messages
└────────────────────────────────┘

REDIRECTION:
# Output to file
$ ls > files.txt        # Overwrite
$ ls >> files.txt       # Append

# Input from file
$ sort < unsorted.txt

# Error to file
$ command 2> errors.txt

# Both output and errors
$ command > output.txt 2>&1

# Discard output
$ command > /dev/null

# Discard errors
$ command 2> /dev/null

PIPES:
Chain commands together
$ cat file.txt | grep "error" | wc -l
  stdin ←───── stdout ←───── stdout

EXAMPLE:
$ ls -l | grep "txt" | sort
     ↓        ↓         ↓
   list → filter → sort results

TEE: Write to file AND stdout
$ ls | tee files.txt | wc -l
Saves to files.txt AND counts lines`
          },
          {
            title: 'Device Files',
            description: 'Accessing hardware through files',
            visual: `
DEVICE FILES IN /dev/

BLOCK DEVICES (Random access):
brw-rw---- /dev/sda     ← First hard disk
brw-rw---- /dev/sda1    ← First partition
brw-rw---- /dev/sdb     ← Second hard disk
brw-rw---- /dev/sr0     ← CD-ROM drive

CHARACTER DEVICES (Sequential):
crw-rw-rw- /dev/tty     ← Current terminal
crw-rw-rw- /dev/tty1    ← Virtual console 1
crw------- /dev/ttyS0   ← Serial port
crw-rw-rw- /dev/null    ← Null device
crw-r--r-- /dev/random  ← Random numbers
crw-rw-rw- /dev/zero    ← Infinite zeros

SPECIAL DEVICES:
/dev/null   → Discard all data
$ command > /dev/null   # Silence output

/dev/zero   → Infinite zeros
$ dd if=/dev/zero of=file bs=1M count=100
# Create 100MB file of zeros

/dev/random → Random data
$ head -c 32 /dev/random > keyfile
# Generate 32 random bytes

EXAMPLES:

Read disk directly:
$ sudo dd if=/dev/sda of=backup.img

Write to serial port:
$ echo "Hello" > /dev/ttyS0

Access webcam:
$ ffmpeg -i /dev/video0 capture.mp4

Play audio:
$ cat music.wav > /dev/audio`
          },
          {
            title: 'I/O Scheduling',
            description: 'Optimizing disk access',
            visual: `
PROBLEM: Disk seeks are SLOW
Goal: Minimize head movement

DISK QUEUE:
Requests: [98, 183, 37, 122, 14, 124, 65, 67]
Current position: 53

CFQ (Completely Fair Queuing):
Each process gets fair share of I/O bandwidth
┌─────────────────────────┐
│ Process A: [98, 37, 14] │
│ Process B: [183, 122]   │
│ Process C: [124, 65, 67]│
└─────────────────────────┘
Round-robin between processes

DEADLINE SCHEDULER:
Prevents I/O starvation
Read requests: 500ms deadline
Write requests: 5s deadline
If deadline near → High priority

NOOP (No-Op):
Simple FIFO queue
Good for SSD (no seek time)
Service in order received

VIEWING I/O SCHEDULER:
$ cat /sys/block/sda/queue/scheduler
noop deadline [cfq]
       ↑ Active scheduler

CHANGING SCHEDULER:
$ echo deadline > /sys/block/sda/queue/scheduler

MONITORING I/O:
$ iostat -x 1
Device  r/s   w/s  rMB/s  wMB/s  await
sda    45.2  12.3   2.1    0.5    5.2

$ iotop
  PID  USER  DISK READ  DISK WRITE  COMMAND
 1234  john    15.2 M/s    0 B/s   chrome`
          }
        ]
      },
      {
        id: 'linux-security',
        title: 'Linux Security',
        content: `Linux implements multiple layers of security including user permissions, SELinux/AppArmor, firewalls, and encrypted communications.`,
        keyPoints: [
          'User and group-based permissions',
          'Root (superuser) has full system access',
          'SELinux: Mandatory Access Control',
          'sudo: Temporary privilege elevation',
          'Firewall: iptables/nftables',
          'SSH: Secure remote access'
        ],
        examples: [
          {
            title: 'User and Group Security',
            description: 'Access control basics',
            visual: `
USERS AND GROUPS:

/etc/passwd (User database):
john:x:1000:1000:John Doe:/home/john:/bin/bash
│    │  │    │    │         │           └─ Shell
│    │  │    │    │         └─ Home directory
│    │  │    │    └─ Full name
│    │  │    └─ Primary group ID
│    │  └─ User ID
│    └─ Password (x = in /etc/shadow)
└─ Username

/etc/group (Group database):
developers:x:1001:john,jane,bob
│          │  │    └─ Members
│          │  └─ Group ID
│          └─ Password
└─ Group name

/etc/shadow (Encrypted passwords):
john:$6$abc...:18900:0:99999:7:::
     └─ Encrypted password

USER MANAGEMENT:
$ sudo useradd john          # Create user
$ sudo passwd john           # Set password
$ sudo usermod -aG sudo john # Add to group
$ sudo userdel john          # Delete user

GROUP MANAGEMENT:
$ sudo groupadd developers
$ sudo usermod -aG developers john
$ groups john                # List user's groups

SWITCHING USERS:
$ su - john        # Switch to john
$ sudo command     # Run as root
$ sudo su -        # Become root

WHO'S LOGGED IN:
$ who              # Current users
$ w                # What they're doing
$ last             # Login history`
          },
          {
            title: 'sudo and Root Access',
            description: 'Privilege elevation',
            visual: `
ROOT USER (UID 0):
✓ Can do ANYTHING
✓ No permission checks
✓ Dangerous if misused!

SUDO: "Substitute User DO"
Run commands as another user (usually root)

/etc/sudoers configuration:
# User privilege specification
root    ALL=(ALL:ALL) ALL
john    ALL=(ALL:ALL) ALL
jane    ALL=(ALL) NOPASSWD: /usr/bin/systemctl

Format: user HOSTS=(USERS:GROUPS) COMMANDS

EXAMPLES:
$ sudo apt update          # Root required
[sudo] password for john:  ← Enter password
...

$ sudo -u jane command     # Run as jane
$ sudo -i                  # Login as root
$ sudo !!                  # Repeat last command as root

VISUDO:
Edit /etc/sudoers safely
$ sudo visudo

SUDO LOG:
/var/log/auth.log
Oct 21 10:30:15 sudo: john : TTY=pts/0 ;
  PWD=/home/john ; USER=root ; COMMAND=/usr/bin/apt update

BEST PRACTICES:
✗ Don't run as root constantly
✓ Use sudo for specific commands
✓ Log sudo usage
✓ Use NOPASSWD sparingly
✓ Audit sudo access regularly

WHY NOT LOGIN AS ROOT?
1. Mistakes are permanent
2. No audit trail of who did what
3. Malware runs with full access
4. Best practice: Use sudo`
          },
          {
            title: 'SELinux Security',
            description: 'Mandatory Access Control',
            visual: `
SELINUX: Security-Enhanced Linux
Adds mandatory access control (MAC)

TRADITIONAL SECURITY (DAC):
User john owns file.txt with rw-------
John decides who can access it

SELINUX (MAC):
System policy decides access
Even root can be restricted!

SELINUX MODES:
Enforcing  → Blocks violations
Permissive → Warns but allows
Disabled   → Off

$ getenforce
Enforcing

$ sudo setenforce 0  # Permissive
$ sudo setenforce 1  # Enforcing

SELINUX CONTEXTS:
Every file, process has security label
$ ls -Z file.txt
-rw-r--r--. john john unconfined_u:object_r:user_home_t:s0 file.txt
                      └───── SELinux context ──────┘

Format: user:role:type:level

EXAMPLE:
Web server (httpd) can only access:
- Files labeled httpd_sys_content_t
- Network ports 80, 443

Even if httpd compromised:
✗ Cannot read /etc/shadow
✗ Cannot write /home/
✗ Cannot connect to random ports

TROUBLESHOOTING:
$ sudo ausearch -m avc -ts recent
# View SELinux denials

$ sudo sealert -a /var/log/audit/audit.log
# Detailed analysis

CHANGE CONTEXT:
$ chcon -t httpd_sys_content_t /var/www/html/file.html

$ restorecon /var/www/html/file.html
# Restore default context

POLICIES:
View: $ semanage boolean -l
Enable: $ setsebool httpd_can_network_connect on`
          },
          {
            title: 'Firewall (iptables)',
            description: 'Network security',
            visual: `
IPTABLES: Linux firewall

CHAINS:
INPUT   → Incoming traffic
OUTPUT  → Outgoing traffic
FORWARD → Routed traffic

TABLES:
filter  → Firewall rules (default)
nat     → Network Address Translation
mangle  → Packet alteration

RULES:
Match packets → Take action

ACTIONS:
ACCEPT → Allow
DROP   → Silently discard
REJECT → Discard with error

EXAMPLES:

# View rules
$ sudo iptables -L -n -v

# Allow SSH (port 22)
$ sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT

# Allow HTTP and HTTPS
$ sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
$ sudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT

# Allow established connections
$ sudo iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Block specific IP
$ sudo iptables -A INPUT -s 192.168.1.100 -j DROP

# Allow from specific network
$ sudo iptables -A INPUT -s 192.168.1.0/24 -j ACCEPT

# Default policy: Drop everything else
$ sudo iptables -P INPUT DROP

# Save rules
$ sudo iptables-save > /etc/iptables/rules.v4

# Restore rules
$ sudo iptables-restore < /etc/iptables/rules.v4

UFW (Uncomplicated Firewall):
Easier frontend for iptables

$ sudo ufw enable
$ sudo ufw allow 22/tcp
$ sudo ufw allow 80/tcp
$ sudo ufw allow 443/tcp
$ sudo ufw status
Status: active
To                         Action
22/tcp                     ALLOW
80/tcp                     ALLOW
443/tcp                    ALLOW`
          }
        ]
      }
    ]
  }
];
